Overrides work by giving you access to a subcomponent and allows you to override any of the 3 parts of its structure. GEL allows for multiple ways to introduce overrides to a component all of which use the same override API.

### Top level API

GEL overrides always take the form of an object, mapping the 3 parts of a subcomponent with a corresponding function.

overrides = { \[subcomponent\]: { styles: (styles, props) => {}, attributes: (attributes, props) => {}, component: (props) => {} } }

overrides \= {

\[subcomponent\]: {

    styles: (styles, props) \=> {},

    attributes: (attributes, props) \=> {},

    component: (props) \=> {}

}

}

/\*\* \* Reset the text fill color so that placeholder is visible \*/ .npm\_\_react-simple-code-editor\_\_textarea:empty { -webkit-text-fill-color: inherit !important; } /\*\* \* Hack to apply on some CSS on IE10 and IE11 \*/ @media all and (-ms-high-contrast: none), (-ms-high-contrast: active) { /\*\* \* IE doesn't support '-webkit-text-fill-color' \* So we use 'color: transparent' to make the text transparent on IE \* Unlike other browsers, it doesn't affect caret color in IE \*/ .npm\_\_react-simple-code-editor\_\_textarea { color: transparent !important; } .npm\_\_react-simple-code-editor\_\_textarea::selection { background-color: #accef7 !important; color: transparent !important; } }

As part of override reconciliation that is handled by the top level component, each of these functions will be passed the props that the default subcomponent needs to work. Styles and attributes also receive the current default styles and attributes for that subcomponent allowing for you to reuse and modify, or for you to disregard them and use completely new styles and attributes.

Another useful thing we pass to components as part of props is a 'state' object. The 'state' object contains all the props passed and any internal state used at the top-most level of the component.
